#!/usr/bin/env python3
from llm_api import ask_openai                                   # Import API call function

import sys
from enum import Enum
from typing import Optional

import re
from typing import Tuple, Union

def parse_line_range(s: str) -> Union[Tuple[int], Tuple[int, int]]:
    """
    Parses a string that can represent:

    - a single integer "12"
    - two integers separated by one of these delimiters: "-", ",", "--", ".", ".."
    
    Returns:
        (int,) or (int, int)
        
    Raises:
        ValueError if the string doesn't conform.
    """
    s = s.strip()
    # Pattern to match two numbers separated by delimiters: - , -- . ..
    # We'll consider any of these delimiters, only one of them should exist between two numbers.
    # To be flexible, we consider the longest delimiter first (--, ..), then single (-, .)
    delimiters = ["--", "-", ",", "..", "."]

    # Try single number first
    if re.fullmatch(r"\d+", s):
        return (int(s),)

    # Try to split by delimiters, trying longest first to avoid splitting "12--13" as "12", "-13"
    for delim in delimiters:
        parts = s.split(delim)
        if len(parts) == 2:
            left, right = parts[0].strip(), parts[1].strip()
            if left.isdigit() and right.isdigit():
                return (int(left), int(right))

    raise ValueError(f"String '{s}' is not a recognized integer or integer range with delimiters.")

class InputKind(Enum):
    Message = "message"
    File = "file"
    Line = "line"

def parse_prompt_args(args) -> str:
    """
    Parse argv manually to support interleaved -m/--message and -f/--file flags,
    preserving their order in the input.
    """
    flag = Optional[InputKind]
    filename: Optional[str] = None
    insertedFile: bool = False
    i = 0
    prompt: str = ""

    def insert_on_newline(prompt: str, new_msg: str)-> str:
        if prompt == "":
            prompt = new_msg
        else:
            prompt = prompt + "\n\n" + new_msg
        return prompt

    while i < len(args):
        arg = args[i]
        # First checks whether the flags are raised, so you can cancel flags 'gill -f -m "msg"' == 'gill -m "msg"'
        if arg in ("-m", "--message"):
            flag = InputKind.Message
        elif arg in ("-f", "--file"):
            flag = InputKind.File
        elif arg in ("-l", "--line"):
            flag = InputKind.Line
        # Argument is not a flag, so execute if you have a flag on
        elif flag == InputKind.Message:
            prompt = insert_on_newline(prompt, arg) # Can stack messages: ```-m "Msg number 1" "Msg number 2"```
        elif flag == InputKind.File:
            # If file is already inserted then can just go to next, otherwise insert it
            if filename and not insertedFile:
                try:
                    with open(filename, "r") as f:
                        content = f.read()
                        prompt = insert_on_newline(prompt, f"```{filename}\n{content}\n```")
                except OSError as e:
                    print(f"Failed reading file {arg}: {e}", file=sys.stderr)
                    raise sys.exit(1)                           # Issue here with inserting only after new file has been given, instead of where the old file was given, can cause mistakes
            filename = arg # Can stack filenames: ```-f file0 file1```
            # Can think of insertedFile as turning True then False again
        elif flag == InputKind.Line:
            if not filename:
                print("No filename given yet.")
                raise sys.exit(1)
            else:
                # Parse the requested lines, e.g. "12", "12-15", "12,15"
                try:
                    lines_spec = parse_line_range(arg)
                    # Determine which lines to keep
                    if len(lines_spec) == 1:
                        start = lines_spec[0]
                        end = start
                    else:
                        start, end = lines_spec
                except ValueError as e:
                    print(f"Invalid line range '{arg}': {e}", file=sys.stderr)
                    sys.exit(1)
    
                # Open whole file as array of lines
                try:
                    with open(filename, "r") as f:
                        all_lines = f.readlines()
                except OSError as e:
                    print(f"Failed reading file {arg}: {e}", file=sys.stderr)
                    raise sys.exit(1)
                
                # Clip to valid line numbers within file
                start = max(start, 1)
                end = min(end, len(all_lines))
                if start > end:
                    print(f"Invalid line range: start ({start}) > end ({end})", file=sys.stderr)
                    sys.exit(1)

                selected_lines = all_lines[start-1 : end]  # 0-based slicing

                # Join selected lines into a string
                selected_content = ''.join(selected_lines).rstrip('\n')  # strip trailing newlines to control output

                # Insert with filename header and fenced code block
                if len(lines_spec) == 1:
                    insertion = f"```{filename}, line {start}\n{selected_content}\n```"
                else:
                    insertion = f"```{filename}, lines {start}-{end}\n{selected_content}\n```"
                prompt = insert_on_newline(prompt, insertion)
                insertedFile = True                             # Tracker to show you don't need to insert the whole file
            # Can stack lines: ```-f file0 -l 2-14 25 30-45``` so flag is not cleared
            # Not stopped from inserting lines in weird combinations!
        else:                                                   # Comes when no message or filename flags have been made
            raise ValueError(f"Unexpected argument {args[i]}")
        i += 1
    return prompt

def main() -> None:
    debugBool: bool = False
    testBool: bool = False                                      # Set True with "--test" flag
    args = sys.argv[1:]                                         # Cut out the gill command

    if debugBool:
        print(f"args are: ", args)

    if args[0] == "--test":
        testBool = True
        args = args[1:]

    try:
        prompt = parse_prompt_args(args)
    except ValueError as e:
        print(f"Argument error: {e}", file=sys.stderr)
        sys.exit(1)

    if prompt == "":
        print("Error: Provide at least one -m or -f option with content.", file=sys.stderr)
        sys.exit(1)

    if testBool or debugBool:
        print(prompt)
    else:
        try:
            response = ask_openai(prompt)                       # Call OpenAI API function
            print(response)
        except Exception as e:
            print(f"OpenAI API error: {e}", file=sys.stderr)
            sys.exit(1)

if __name__ == "__main__":
    main()